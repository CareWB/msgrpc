/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef api_TYPES_H
#define api_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace org { namespace example { namespace msgrpc { namespace thrift {

class SingleOptionalFieldStruct;

class EmbeddedStruct;

class ResponseData;

typedef struct _SingleOptionalFieldStruct__isset {
  _SingleOptionalFieldStruct__isset() : value(false) {}
  bool value :1;
} _SingleOptionalFieldStruct__isset;

class SingleOptionalFieldStruct {
 public:

  SingleOptionalFieldStruct(const SingleOptionalFieldStruct&);
  SingleOptionalFieldStruct& operator=(const SingleOptionalFieldStruct&);
  SingleOptionalFieldStruct() : value(0) {
  }

  virtual ~SingleOptionalFieldStruct() throw();
  int16_t value;

  _SingleOptionalFieldStruct__isset __isset;

  void __set_value(const int16_t val);

  bool operator == (const SingleOptionalFieldStruct & rhs) const
  {
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const SingleOptionalFieldStruct &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SingleOptionalFieldStruct & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SingleOptionalFieldStruct &a, SingleOptionalFieldStruct &b);

inline std::ostream& operator<<(std::ostream& out, const SingleOptionalFieldStruct& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _EmbeddedStruct__isset {
  _EmbeddedStruct__isset() : es_i8(false), es_i16(false) {}
  bool es_i8 :1;
  bool es_i16 :1;
} _EmbeddedStruct__isset;

class EmbeddedStruct {
 public:

  EmbeddedStruct(const EmbeddedStruct&);
  EmbeddedStruct& operator=(const EmbeddedStruct&);
  EmbeddedStruct() : es_i8(0), es_i16(0) {
  }

  virtual ~EmbeddedStruct() throw();
  int8_t es_i8;
  int16_t es_i16;

  _EmbeddedStruct__isset __isset;

  void __set_es_i8(const int8_t val);

  void __set_es_i16(const int16_t val);

  bool operator == (const EmbeddedStruct & rhs) const
  {
    if (!(es_i8 == rhs.es_i8))
      return false;
    if (!(es_i16 == rhs.es_i16))
      return false;
    return true;
  }
  bool operator != (const EmbeddedStruct &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const EmbeddedStruct & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(EmbeddedStruct &a, EmbeddedStruct &b);

inline std::ostream& operator<<(std::ostream& out, const EmbeddedStruct& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ResponseData__isset {
  _ResponseData__isset() : pet_id(false), pet_name(false), pet_weight(false), pet_i8_value(false), pet_i16_value(false), pet_i64_value(false), pet_double_value(false), pet_bool_value(false), pet_binary_value(false), pet_embedded_struct(false), pet_list_i32(false), pet_list_of_struct(false), pet_list_of_bool(false), pet_set_of_i32(false), pet_set_of_struct(false), pet_map_i32_string(false), pet_map_string_struct(false) {}
  bool pet_id :1;
  bool pet_name :1;
  bool pet_weight :1;
  bool pet_i8_value :1;
  bool pet_i16_value :1;
  bool pet_i64_value :1;
  bool pet_double_value :1;
  bool pet_bool_value :1;
  bool pet_binary_value :1;
  bool pet_embedded_struct :1;
  bool pet_list_i32 :1;
  bool pet_list_of_struct :1;
  bool pet_list_of_bool :1;
  bool pet_set_of_i32 :1;
  bool pet_set_of_struct :1;
  bool pet_map_i32_string :1;
  bool pet_map_string_struct :1;
} _ResponseData__isset;

class ResponseData {
 public:

  ResponseData(const ResponseData&);
  ResponseData& operator=(const ResponseData&);
  ResponseData() : pet_id(0), pet_name(), pet_weight(0), pet_i8_value(0), pet_i16_value(0), pet_i64_value(0), pet_double_value(0), pet_bool_value(0), pet_binary_value() {
  }

  virtual ~ResponseData() throw();
  int32_t pet_id;
  std::string pet_name;
  int32_t pet_weight;
  int8_t pet_i8_value;
  int16_t pet_i16_value;
  int64_t pet_i64_value;
  double pet_double_value;
  bool pet_bool_value;
  std::string pet_binary_value;
  EmbeddedStruct pet_embedded_struct;
  std::vector<int32_t>  pet_list_i32;
  std::vector<EmbeddedStruct>  pet_list_of_struct;
  std::vector<bool>  pet_list_of_bool;
  std::set<int32_t>  pet_set_of_i32;
  std::set<EmbeddedStruct>  pet_set_of_struct;
  std::map<int32_t, std::string>  pet_map_i32_string;
  std::map<std::string, EmbeddedStruct>  pet_map_string_struct;

  _ResponseData__isset __isset;

  void __set_pet_id(const int32_t val);

  void __set_pet_name(const std::string& val);

  void __set_pet_weight(const int32_t val);

  void __set_pet_i8_value(const int8_t val);

  void __set_pet_i16_value(const int16_t val);

  void __set_pet_i64_value(const int64_t val);

  void __set_pet_double_value(const double val);

  void __set_pet_bool_value(const bool val);

  void __set_pet_binary_value(const std::string& val);

  void __set_pet_embedded_struct(const EmbeddedStruct& val);

  void __set_pet_list_i32(const std::vector<int32_t> & val);

  void __set_pet_list_of_struct(const std::vector<EmbeddedStruct> & val);

  void __set_pet_list_of_bool(const std::vector<bool> & val);

  void __set_pet_set_of_i32(const std::set<int32_t> & val);

  void __set_pet_set_of_struct(const std::set<EmbeddedStruct> & val);

  void __set_pet_map_i32_string(const std::map<int32_t, std::string> & val);

  void __set_pet_map_string_struct(const std::map<std::string, EmbeddedStruct> & val);

  bool operator == (const ResponseData & rhs) const
  {
    if (!(pet_id == rhs.pet_id))
      return false;
    if (!(pet_name == rhs.pet_name))
      return false;
    if (!(pet_weight == rhs.pet_weight))
      return false;
    if (!(pet_i8_value == rhs.pet_i8_value))
      return false;
    if (!(pet_i16_value == rhs.pet_i16_value))
      return false;
    if (!(pet_i64_value == rhs.pet_i64_value))
      return false;
    if (!(pet_double_value == rhs.pet_double_value))
      return false;
    if (!(pet_bool_value == rhs.pet_bool_value))
      return false;
    if (!(pet_binary_value == rhs.pet_binary_value))
      return false;
    if (!(pet_embedded_struct == rhs.pet_embedded_struct))
      return false;
    if (!(pet_list_i32 == rhs.pet_list_i32))
      return false;
    if (!(pet_list_of_struct == rhs.pet_list_of_struct))
      return false;
    if (!(pet_list_of_bool == rhs.pet_list_of_bool))
      return false;
    if (!(pet_set_of_i32 == rhs.pet_set_of_i32))
      return false;
    if (!(pet_set_of_struct == rhs.pet_set_of_struct))
      return false;
    if (!(pet_map_i32_string == rhs.pet_map_i32_string))
      return false;
    if (!(pet_map_string_struct == rhs.pet_map_string_struct))
      return false;
    return true;
  }
  bool operator != (const ResponseData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ResponseData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ResponseData &a, ResponseData &b);

inline std::ostream& operator<<(std::ostream& out, const ResponseData& obj)
{
  obj.printTo(out);
  return out;
}

}}}} // namespace

#endif
